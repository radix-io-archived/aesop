#include <unistd.h>

#include "src/common/triton-types.h"
#include "src/aesop/hints.h"
#include "src/aesop/aesop.h"
#include "src/remote/encoding.h"
#include "src/remote/remote.hae"
#include "src/net/triton-message.hae"
#include "src/net/triton-message-method.hae"
#include "src/net/mock/mock-method.h"
#include "src/common/resources/scheduling/sched.hae"
#include "src/common/resources/timer/timer.hae"
#include "src/zeroconf/zeroconf.h"
#include "src/net/mpi/mpi.hae"
#include "src/net/mpi/mpi-method.h"
#include "src/net/fault-injector/fault-method.h"
#include "src/remote/service.hae"
#include "src/common/triton-init.h"


/* normally you don't have to declare this, but we do here because
 * it gets declared in <module>_module.h (myclientserver_module.h)
 * which is generated by this source file.
 */
triton_ret_t aer_remote_register_test_remote_fault(void); 

#include "mpi.h"

static float failure_rate = 0;

__remote __blocking triton_ret_t scatter_gather(int32_t in, int32_t *out);

__remote __blocking triton_ret_t scatter_gather(int32_t in, int32_t *out)
{
    triton_ret_t ret,
                 ret1 = TRITON_SUCCESS,
                 ret2 = TRITON_SUCCESS;
    triton_addr_t from, self, n1, n2;
    triton_string_t fromstr, selfstr;
    int rank, r1, r2, size;
    char n1str[100], n2str[100];
    int32_t res1 = 0, res2 = 0;
    aer_remote_ctx_t rctx;

    ret = aesop_hints_get("triton.remote.context", sizeof(rctx), &rctx);
    triton_error_assert(ret);
    assert(rctx != NULL);

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    printf("scatter_gather: rank=%d, input=%d\n", rank, in);

    if(rank == 0)
    {
        r1 = 1;
        r2 = 2;
    }
    else
    {
        r1 = rank * 2;
        if(rank % 2 == 1) ++r1;
        r2 = r1 + 2;
    }

    sprintf(n1str, "fault://%d", r1);
    ret = triton_addr_lookup(n1str, &n1);
    triton_error_assert(ret);

    sprintf(n2str, "fault://%d", r2);
    ret = triton_addr_lookup(n2str, &n2);
    triton_error_assert(ret);

    pwait
    {
        if(r1 < size)
        {
            pbranch
            {
                printf("scatter_gather: rank=%d :: remote_scatter_gather(node=%d, in=%d)\n", rank, r1, in);
                assert(rctx != NULL);
                ret1 = remote_scatter_gather(rctx, n1, in, &res1);
                if(ret1 != TRITON_SUCCESS)
                {
                    pbreak;
                }
                printf("scatter_gather: rank=%d :: remote_scatter_gather(node=%d, in=%d) done!\n", rank, r1, in);
            }
        }

        if(r2 < size)
        {
            pbranch
            {
                printf("scatter_gather: rank=%d :: remote_scatter_gather(node=%d, in=%d)\n", rank, r2, in);
                assert(rctx != NULL);
                ret2 = remote_scatter_gather(rctx, n2, in, &res2);
                if(ret2 != TRITON_SUCCESS)
                {
                    pbreak;
                }
                printf("scatter_gather: rank=%d :: remote_scatter_gather(node=%d, in=%d) done!\n", rank, r2, in);
            }
        }
    }

    if(ret1 == TRITON_SUCCESS && ret2 == TRITON_SUCCESS)
    {
        *out = res1 + res2 + rank + in;
        printf("scatter_gather: rank=%d => out=%d\n", rank, *out);
        ret = TRITON_SUCCESS;
    }
    else
    {
        ret = (ret1 == TRITON_SUCCESS) ? ret2 : ret1;
        self = triton_addr_self("mpi");
        ret = triton_error_wrap(ret, self, "Error at remote scatter_gather");
    }

    return ret;
}

__blocking void do_remote_test(aer_remote_ctx_t rctx)
{
    triton_ret_t ret;
    int32_t result;
    int rank;

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if(rank == 0)
    {
        /* need a good way to wait for all the processes, so that
         * we know the aer_service_requests calls have been started
         * and will be able to receive messages.  For now, we just sleep
         * for a sec.
         */
        ret = triton_timer(1000);
        triton_error_assert(ret);

        /* must set the remote context as a hint because we're about to call
         * scatter_gather as a local call
         */
        ret = aesop_hints_put("triton.remote.context", sizeof(rctx), &rctx, 1);
        triton_error_assert(ret);

        /* rank 0 calls local scatter_gather, which starts everything */
        ret = scatter_gather(50, &result);
        triton_error_assert(ret);
        printf("FINAL RESULT: %d\n", result);

    }
    else
    {
        /* service a single scatter/gather request */
        assert(rctx != NULL);
        ret = aer_service_requests(rctx, 1);
    }
}

__blocking int aesop_main(int argc, char **argv)
{
    triton_ret_t ret;
    ae_op_id_t op_id;
    int scan_ret;

    if(argc != 2)
    {
        fprintf(stderr, 
            "Usage: test-remote-fault-injector <failure rate (%%)>\n");
        return(-1);
    }

    scan_ret = sscanf(argv[1], "%f", &failure_rate);
    if(scan_ret != 1)
    {
        fprintf(stderr, 
            "Usage: test-remote-fault-injector <failure rate (%%)>\n");
        return(-1);
    }
    if(failure_rate > 100 || failure_rate < 0)
    {
        fprintf(stderr, 
            "Usage: test-remote-fault-injector <failure rate (%%)>\n");
        return(-1);
    }
    triton_zeroconf_set("triton.net.fault_injector.failure_rate", argv[1]);
    triton_zeroconf_set("triton.net.fault_injector.base_method", "mpi");

    /* triton_debug_stderr_enable("all"); */
 
    ret = aer_remote_register_test_remote_fault();
    triton_error_assert(ret);

    do_remote_test(AER_DEFAULT_CTX);

    return 0;
}

static triton_ret_t init_zeroconf_params(int argc, char** argv)
{
    triton_ret_t tret;

    tret = triton_zeroconf_set("aesop.remote.default_net", "fault");
    triton_error_assert(tret);
    
    return(TRITON_SUCCESS);
}

aesop_main_set_with_init(init_zeroconf_params, "triton.client", aesop_main, "mpi", "sched", "timer");


/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 expandtab
 */
