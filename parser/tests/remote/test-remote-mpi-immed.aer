#include <unistd.h>

#include "src/common/triton-types.h"
#include "src/aesop/hints.h"
#include "src/aesop/aesop.h"
#include "src/remote/encoding.h"
#include "src/remote/remote.hae"
#include "src/net/triton-message.hae"
#include "src/net/triton-message-method.hae"
#include "src/net/mock/mock-method.h"
#include "src/common/resources/scheduling/sched.hae"
#include "src/common/resources/timer/timer.hae"
#include "src/zeroconf/zeroconf.h"
#include "src/net/mpi/mpi.hae"
#include "src/net/mpi/mpi-method.h"

#include "src/remote/service.hae"
#include "src/common/triton-init.h"


/* normally you don't have to declare this, but we do here because
 * it gets declared in <module>_module.h (myclientserver_module.h)
 * which is generated by this source file.
 */
triton_ret_t aer_remote_register_test_remote_mpi_immed(void); 

#include "mpi.h"

__remote __blocking triton_ret_t test_fn(triton_ignore_t* in, triton_ignore_t* out);

__remote __blocking triton_ret_t test_fn(triton_ignore_t* in, triton_ignore_t* out)
{
    triton_ret_t tret;

    tret = triton_timer(10);
    printf("finished timer.\n");

    return(tret);
}

__blocking void do_remote_test(aer_remote_ctx_t rctx)
{
    triton_ret_t ret;
    int32_t result;
    int rank;
    const char* svr = "mpi://1";
    triton_addr_t n1;

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if(rank == 0)
    {
        /* need a good way to wait for all the processes, so that
         * we know the aer_service_requests calls have been started
         * and will be able to receive messages.  For now, we just sleep
         * for a sec.
         */
        ret = triton_timer(1000);
        triton_error_assert(ret);

#if 0
        /* must set the remote context as a hint because we're about to call
         * test_fn as a local call
         */
        ret = aesop_hints_put("triton.remote.context", sizeof(rctx), &rctx);
        triton_error_assert(ret);
#endif

        ret = triton_addr_lookup(svr, &n1);
        assert(rctx != NULL);
        ret = remote_test_fn(rctx, n1, NULL, NULL);
        triton_error_assert(ret);
        printf("FINAL RESULT: %d\n", result);

    }
    else
    {
        /* service a single request */
        assert(rctx != NULL);
        ret = aer_service_requests(rctx, 1);
    }
}

__blocking int aesop_main(int argc, char **argv)
{
    triton_ret_t ret;
    ae_op_id_t op_id;

    ret = aer_remote_register_test_remote_mpi_immed();
    triton_error_assert(ret);

    do_remote_test(AER_DEFAULT_CTX);

    return 0;
}
aesop_main_set(aesop_main, "mpi", "sched", "timer");


/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 expandtab
 */
