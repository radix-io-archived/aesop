#include <unistd.h>

#include "src/common/triton-types.h"
#include "src/aesop/aesop.h"
#include "src/aesop/hints.h"
#include "src/remote/encoding.h"
#include "src/remote/remote.hae"
#include "src/net/triton-addr.h"
#include "src/net/triton-message.hae"
#include "src/net/triton-message-method.hae"
#include "src/net/mock/mock-method.h"
#include "src/common/resources/scheduling/sched.hae"
#include "src/common/resources/timer/timer.hae"
#include "src/zeroconf/zeroconf.h"

#include "src/remote/service.hae"
#include "src/zeroconf/zeroconf.h"
#include "src/common/triton-init.h"


/* normally you don't have to declare this, but we do here because
 * it gets declared in <module>_module.h (myclientserver_module.h)
 * which is generated by this source file.
 */
triton_ret_t aer_remote_register_test_remote_mock_buf(void); 

static aer_remote_ctx_t remote_ctx;

__remote struct myremotes
{
    int32_t t1;
    uint64_t ut1;
    triton_buffer_t buf;
};

__remote __blocking triton_ret_t remote_with_buffer(struct myremotes *in, struct myremotes *out);

__remote __blocking triton_ret_t remote_with_buffer(struct myremotes *in, struct myremotes *out)
{
    triton_ret_t ret;
    triton_addr_t from, self;
    triton_string_t fromstr, selfstr;
    int i;

    /* do a blocking call here just so we have something */
    ret = triton_timer(10);

    out->t1 = in->t1;
    out->ut1 = 100;

    /* must be freed by caller on client side, gets freed by servicing code on service side */
    triton_buffer_alloc(&out->buf, in->buf.size);
    memcpy(out->buf.buffer, in->buf.buffer, in->buf.size);

    ret = aesop_hints_get("triton.mock.self", sizeof(self), &self);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }
    ret = triton_addr_to_string(self, &selfstr);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }

    ret = aesop_hints_get("triton.remote.from", sizeof(from), &from);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }
    ret = triton_addr_to_string(from, &fromstr);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }

    printf("remote_with_buffer invoked from (%s -> %s):  in: (%d,%llu) out: (%d,%llu)\n",
           fromstr.string, selfstr.string, in->t1, llu(in->ut1), out->t1, llu(out->ut1));
    printf("remote_with_buffer in->buf (size=%u): ", in->buf.size);
    for(i = 0; i < in->buf.size; ++i)
    {
        printf("%x:", in->buf.buffer[i]);
    }
    printf("\n");

    triton_string_destroy(&fromstr);

    return ret;
}

__blocking void do_remote_clients(int count)
{
    triton_ret_t ret;
    int32_t fun1res;

    pwait
    {
        pprivate triton_addr_t self, node0;
        pprivate int i;
        pprivate char nodestr[100];
        pprivate struct myremotes in, out;

        for(i = 0; i < count; ++i)
        {
            pbranch
            {

                /* kind of a hack, we setup the nodes here by doing a lookup of a node string
                 * in the mock method and then for this pbranch, tell the mock method what its
                 * current address is using hints.
                 * Future triton_addr_self() calls will return this addr.
                 */ 
                sprintf(nodestr, "mock://%d", i);
                ret = triton_addr_lookup(nodestr, &self);
                triton_error_assert(ret);
                ret = aesop_hints_put("triton.mock.self", sizeof(self), &self, 1);
                triton_error_assert(ret);

                ret = triton_addr_lookup("mock://0", &node0);
                triton_error_assert(ret);

                in.t1 = 100;
                in.ut1 = 0;
                triton_buffer_alloc(&in.buf, 42);
                memset(in.buf.buffer, i, 42);

                ret = remote_remote_with_buffer(remote_ctx, node0, &in, &out);
                triton_error_assert(ret);
                assert(out.t1 == 100);
                assert(out.ut1 == 100);
                assert(!memcmp(in.buf.buffer, out.buf.buffer, in.buf.size));

                triton_buffer_destroy(&in.buf);
                triton_buffer_destroy(&out.buf);
            }
        }
    }
}

__blocking void do_remote_test(int count)
{
    triton_string_t selfstr;
    triton_ret_t ret;

    pwait
    {
        pprivate triton_addr_t self;

        pbranch
        {
            /* tell the server what its address is */

            ret = triton_addr_lookup("mock://0", &self);
            triton_error_assert(ret);
            ret = aesop_hints_put("triton.mock.self", sizeof(self), &self, 1);
            triton_error_assert(ret);

            /* start server */
            aer_service_engine_start(AER_DEFAULT_CTX);
        }

        pbranch
        {
            do_remote_clients(count);
            /* clients done.  stop service engine */
            aer_service_engine_stop();
        }
    }
}

static int done = 0;
static void cb(void *up)
{
    ae_context_t ctx = (ae_context_t)up;
    done=1;
    ae_poll_break(ctx);
}

int main(int argc, char *argv[])
{
    triton_ret_t ret;
    ae_op_id_t op_id;
    ae_context_t mock_resource_ctx;
    ae_hints_t hints;

    if(argc < 2)
    {
        printf("usage: %s <clientnum> [-d]\n", argv[0]);
        exit(1);
    }
    assert(argc > 1);

    ret = triton_init("triton.client");
    triton_error_assert(ret);

    if(argc > 2)
    {
        triton_debug_enable("/dev/stdout", "all");
    }

    ret = ae_hints_type_register("triton.mock.self", 0, NULL);
    triton_error_assert(ret);

    ret = aer_remote_register_test_remote_mock_buf();
    triton_error_assert(ret);

    ret = ae_context_create(&mock_resource_ctx, "sched", "timer");
    triton_error_assert(ret);

    ae_hints_init(&hints);

    ret = ae_post_blocking(do_remote_test, cb, mock_resource_ctx, &hints, mock_resource_ctx, &op_id, atoi(argv[1]));
    while(!done)
    {
        ae_poll(mock_resource_ctx, 0);
    }

    ae_hints_destroy(&hints);

    return 0;
}

/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 expandtab
 */
