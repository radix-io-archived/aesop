#include <unistd.h>

#include "src/common/triton-types.h"
#include "src/aesop/hints.h"
#include "src/aesop/aesop.h"
#include "src/remote/encoding.h"
#include "src/remote/remote.hae"
#include "src/net/triton-message.hae"
#include "src/net/triton-message-method.hae"
#include "src/net/mock/mock-method.h"
#include "src/common/resources/scheduling/sched.hae"
#include "src/common/resources/timer/timer.hae"
#include "src/zeroconf/zeroconf.h"
#include "src/net/mpi/mpi.hae"
#include "src/net/mpi/mpi-method.h"

#include "src/remote/service.hae"
#include "src/common/triton-init.h"


/* normally you don't have to declare this, but we do here because
 * it gets declared in <module>_module.h (myclientserver_module.h)
 * which is generated by this source file.
 */
triton_ret_t aer_remote_register_test_remote_buffer_response(void); 

#include "mpi.h"

__remote struct test_resp
{
    triton_buffer_t buffer;
};

__remote __blocking triton_ret_t buffer_maker(int32_t in, struct test_resp *resp);

__remote __blocking triton_ret_t buffer_maker(int32_t in, struct test_resp *resp)
{
    triton_ret_t tret;

    /* just allocate an empty buffer to send in the response */
    tret = triton_buffer_alloc(&resp->buffer, 10);

    return(tret);
}

__blocking void do_remote_test(aer_remote_ctx_t rctx)
{
    triton_ret_t ret;
    int32_t result;
    int rank;
    triton_addr_t addr;
    char addr_str[256];
    struct test_resp resp;

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if(rank == 0)
    {
        /* need a good way to wait for all the processes, so that
         * we know the aer_service_requests calls have been started
         * and will be able to receive messages.  For now, we just sleep
         * for a sec.
         */
        ret = triton_timer(1000);
        triton_error_assert(ret);

        sprintf(addr_str, "mpi://1");

        ret = triton_addr_lookup(addr_str, &addr);
        triton_error_assert(ret);

        ret = remote_buffer_maker(rctx, addr, 0, &resp);
        triton_error_assert(ret);

        if(ret == TRITON_SUCCESS)
        {
            aer_destroy_struct_test_resp(&resp);
        }
    }
    else
    {
        /* service a single request */
        assert(rctx != NULL);
        ret = aer_service_requests(rctx, 1);
    }
}

__blocking int aesop_main(int argc, char **argv)
{
    triton_ret_t ret;
    ae_op_id_t op_id;

    ret = aer_remote_register_test_remote_buffer_response();
    triton_error_assert(ret);

    do_remote_test(AER_DEFAULT_CTX);

    return 0;
}
aesop_main_set_with_init(NULL, "triton.client", aesop_main, "mpi", "sched", "timer");


/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 expandtab
 */
