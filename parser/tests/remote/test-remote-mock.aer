#include <unistd.h>

#include "src/common/triton-types.h"
#include "src/aesop/aesop.h"
#include "src/aesop/hints.h"
#include "src/remote/encoding.h"
#include "src/remote/remote.hae"
#include "src/net/triton-addr.h"
#include "src/net/triton-message.hae"
#include "src/net/triton-message-method.hae"
#include "src/net/mock/mock-method.h"
#include "src/common/resources/scheduling/sched.hae"
#include "src/common/resources/timer/timer.hae"
#include "src/zeroconf/zeroconf.h"

#include "src/remote/service.hae"
#include "src/zeroconf/zeroconf.h"
#include "src/common/triton-init.h"

static aer_remote_ctx_t remote_ctx;

__remote struct myremotes
{
    int32_t t1;
    uint64_t ut1;
};

__remote __blocking triton_ret_t remotefun1(int32_t in, int32_t *out);

__remote __blocking triton_ret_t remotefun1(int32_t in, int32_t *out)
{
    triton_ret_t ret;
    triton_addr_t from, self;
    triton_string_t fromstr, selfstr;

    /* do a blocking call here just so we have something */
    triton_timer(10);

    *out = in;

    ret = aesop_hints_get("triton.mock.self", sizeof(self), &self);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }
    ret = triton_addr_to_string(self, &selfstr);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }


    ret = aesop_hints_get("triton.remote.from", sizeof(from), &from);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }
    ret = triton_addr_to_string(from, &fromstr);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }

    printf("remotefun1 invoked ( %s -> %s ):  in: %d, out: %d\n", fromstr.string, selfstr.string, in, *out);

    triton_string_destroy(&fromstr);
    triton_string_destroy(&selfstr);

    return TRITON_SUCCESS;
}

__remote __blocking triton_ret_t remotefun2(struct myremotes *in, struct myremotes *out);

__remote __blocking triton_ret_t remotefun2(struct myremotes *in, struct myremotes *out)
{
    triton_ret_t ret;
    triton_addr_t from, self;
    triton_string_t fromstr, selfstr;

    /* do a blocking call here just so we have something */
    ret = triton_timer(10);

    out->t1 = in->t1;
    out->ut1 = 100;

    ret = aesop_hints_get("triton.mock.self", sizeof(self), &self);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }
    ret = triton_addr_to_string(self, &selfstr);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }

    ret = aesop_hints_get("triton.remote.from", sizeof(from), &from);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }
    ret = triton_addr_to_string(from, &fromstr);
    if(ret != TRITON_SUCCESS)
    {
        return ret;
    }

    printf("remotefun2 invoked from (%s -> %s):  in: (%d,%llu) out: (%d,%llu)\n",
           fromstr.string, selfstr.string, in->t1, llu(in->ut1), out->t1, llu(out->ut1));

    triton_string_destroy(&fromstr);

    return ret;
}

__blocking void do_remote_clients(int count)
{
    triton_ret_t ret;
    struct myremotes in, out;
    int32_t fun1res;

    pwait
    {
        pprivate triton_addr_t self, node0;
        pprivate int i;
        pprivate char nodestr[100];

        for(i = 0; i < count; ++i)
        {
            pbranch
            {
                /* kind of a hack, we setup the nodes here by doing a lookup of a node string
                 * in the mock method and then for this pbranch, tell the mock method what its
                 * current address is using hints.
                 * Future triton_addr_self() calls will return this addr.
                 */ 
                sprintf(nodestr, "mock://%d", i);
                ret = triton_addr_lookup(nodestr, &self);
                triton_error_assert(ret);
                ret = aesop_hints_put("triton.mock.self", sizeof(self), &self);
                triton_error_assert(ret);

                ret = triton_addr_lookup("mock://0", &node0);
                triton_error_assert(ret);

                ret = remote_remotefun1(remote_ctx, node0, 10, &fun1res);
                triton_error_assert(ret);
                assert(fun1res == 10);

                in.t1 = 100;
                in.ut1 = 0;
                ret = remote_remotefun2(remote_ctx, node0, &in, &out);
                triton_error_assert(ret);
                assert(out.t1 == 100);
                assert(out.ut1 == 100);
            }
        }
    }
}

__blocking void do_remote_test(int count)
{
    triton_string_t selfstr;
    triton_ret_t ret;

    ret = aer_remote_ctx_init(&remote_ctx, "triton.remote.retry", "mock");
    triton_error_assert(ret);

    pwait
    {
        pprivate triton_addr_t self;

        pbranch
        {
            /* tell the server what its address is */

            ret = triton_addr_lookup("mock://0", &self);
            triton_error_assert(ret);
            ret = aesop_hints_put("triton.mock.self", sizeof(self), &self);
            triton_error_assert(ret);

            /* start server */
            aer_service_engine_start(remote_ctx);
        }

        pbranch
        {
            do_remote_clients(count);
            /* clients done.  stop service engine */
            aer_service_engine_stop();
        }
    }
}

__blocking int aesop_main(int argc, char **argv)
{
    triton_ret_t ret;
    ae_op_id_t op_id;
    aer_remote_ctx_t rctx;

    if(argc < 2)
    {
        printf("usage: %s <clientnum> [-d]\n", argv[0]);
        exit(1);
    }
    assert(argc > 1);

    ret = aer_remote_register_test_remote_mock();
    triton_error_assert(ret);

    ret = ae_hints_type_register("triton.mock.self", 0, NULL);
    triton_error_assert(ret);

    ret = triton_msg_enable_method("mock");
    triton_error_assert(ret);

    do_remote_test(atoi(argv[1]));

    aer_remote_ctx_destroy(rctx);

    return 0;
}
aesop_main_set(aesop_main, 3, "mock", "sched", "timer");

/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 expandtab
 */
