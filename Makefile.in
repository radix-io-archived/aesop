###############################################################
# General documentation
#
# This is a single makefile that runs the entire Aesop build
# process.  There are no makefiles in subdirectories.  For a
# general introduction to this approach, please read this document
# by Peter Miller:
#
# http://www.tip.net.au/~millerp/rmch/recu-make-cons-harm.html
#
# Each subdirectory contains a module.mk file that gets included
# when make is executed.  These module.mk files tell make about the
# files in each subdirectory that must be built, including any
# special case rules.  Make uses this information to generate a
# sinle dependency graph and orchestrate the build process from this
# top level directory.
#
# We categorize our source depending on what it will be used for.
# For example, there are lists of source files for building the
# server, building the library, building documentation, etc.
#

###############################################################
# Generic makefile setup

# define a few generic variables that we need to use; DESTDIR may
# be overridden on the command line during make install
DESTDIR =
srcdir = @srcdir@
abs_srcdir = @abs_srcdir@
builddir = @BUILD_ABSOLUTE_TOP@
prefix = @prefix@
datarootdir = @datarootdir@
exec_prefix = @exec_prefix@
includedir = $(DESTDIR)@includedir@/aesop
mandir = $(DESTDIR)@mandir@
sbindir = $(DESTDIR)@sbindir@
bindir = $(DESTDIR)@bindir@
libdir = $(DESTDIR)@libdir@

# tools
A2X = @A2X@
ASCIIDOC = @ASCIIDOC@

# subdirs that contain configure/make
SUBDIRS = @subdirs@

VPATH = $(srcdir)
AEPRETTY =
AEDEBUG =
ifneq (,@AE_DEBUG@)
	AEPRETTY = --pretty
	AEDEBUG = @AE_DEBUG@
endif

# for now assume ghc is installed and in path.
GHC = @GHC@

CC = @CC@
LD = @LD@
BUILD_CC = @BUILD_CC@
BUILD_LD = @BUILD_LD@
BUILD_CFLAGS = @BUILD_CFLAGS@
BUILD_LDFLAGS = @BUILD_LDFLAGS@
BUILD_SSM = @BUILD_SSM@

STRICT_CFLAGS = @STRICT_CFLAGS@
VALGRIND_CLEAN = @VALGRIND_CLEAN@
CPPFLAGS = @CPPFLAGS@

ifneq (0,$(VALGRIND_CLEAN))
   CPPFLAGS += -DVALGRIND_CLEAN -DVALGRIND
endif

ifeq ($(BUILD_SSM),1)
   CPPFLAGS += -I@SSMPATH@/common
   LDFLAGS += -L@SSMPATH@/lib
   LIBS += -lssm_ref -lssmp_mpi
endif

CFLAGS= -I$(srcdir)/src/c-utils -I$(srcdir)/include -I. -I src/c-utils -I$(srcdir) @CFLAGS@ $(CPPFLAGS)

# enable relocatable
#CFLAGS += -fPIC

CWARNS=
ifneq (0,$(STRICT_CFLAGS))
	CWARNS += -Wcast-align -Wbad-function-cast
	CWARNS += -Wmissing-prototypes -Wmissing-declarations
	CWARNS += -Wundef -Wpointer-arith
	CWARNS += -Wnested-externs
	CWARNS += -Wredundant-decls
	# Very noisy, too strict
	CWARNS += -W -Wno-sign-compare
	CWARNS += -Wcast-qual
	CWARNS += -Wshadow
	CWARNS += -Wwrite-strings
	CWARNS += -Wformat
endif

# don't want to warn when we call format functions without string literal parameters
# e.g. triton_string_init(&str, myname);
CWARNS += -Wno-format-security
# ... or when we have unused labels, which are common in generated aesop
# code
CWARNS += -Wno-unused-label 

LDSHARED = $(TCC) -shared

LIBCFLAGS=@LIBCFLAGS@
LDFLAGS += @LDFLAGS@ -Lsrc/c-utils 
LIBS += @LIBS@ -lc-utils -lm -lpthread

DEPLIBS += @THREAD_LIB@

CPPDEFS=$(filter -D%,$(LIBCFLAGS) $(CFLAGS))
CPPINCS=$(filter -I%,$(LIBCFLAGS) $(CFLAGS))

CFLAGS += $(MPICFLAGS)
LDFLAGS += $(MPILDFLAGS)
LIBS += $(MPILIBS)

USE_DYLIBS = @USE_DYLIBS@

INSTALL = @INSTALL@

AELIBSRC :=
LIBSRC :=
GENLIBSRC :=
GENLIBHDR :=
AETESTSRC :=
AEPROGRAMSRC :=
AESOP_HDR :=
AETESTLIBSRC :=
TESTLIBSRC :=
HSSRC :=
HSBINSRC :=
TESTSRC :=
PROGRAMSRC :=
TEST_OUT :=
TEST_RESULTS :=

ASCIIDOCSRC :=

# Eliminate all default suffixes.  We want explicit control.
.SUFFIXES:

QUIET_COMPILE = @QUIET_COMPILE@
WARNINGS_AS_ERRORS = @WARNINGS_AS_ERRORS@

ifdef V
    QUIET_COMPILE = 0
endif

ifdef W
	ifeq ($(W),1)
		WARNINGS_AS_ERRORS = 1
	else
		WARNINGS_AS_ERRORS = 0
	endif
endif

ifdef D
  DA="-l"
else
  DA=
endif

ifeq ($(QUIET_COMPILE),1)
  # say a one-line description of the action, do not echo the command
  Q=@echo
  E=@
  VA=
else
  # do not say the short Q lines, but do echo the entire command
  Q=@echo >/dev/null
  E=
  VA="-v"
endif

ifeq ($(WARNINGS_AS_ERRORS),1)
	EWARNS = -Werror
else
	EWARNS =
endif

# PHONY targets are targets that do not result in the generation
#    of a file that has the same name as the target.  Listing them
#    here keeps make from accidentally doing too much work (see GNU
#    make manual).
.PHONY: all clean parserclean test_results 

################################################################
# Find project subdirectories

# MODULES is a list of subdirectories that we wish to operate on.
#    They are identified by the presence of module.mk files (makefile
#    includes).
MODULES := $(shell find . -name "*.mk" |grep -v c-utils| sed -e 's/^.\///;s/module.mk//')


################################################################
# Default target forward pointer, to avoid other targets in make stubs
all::

all:: subdirs


################################################################
# Subdir configure
################################################################
.PHONY: subdirs $(SUBDIRS)
subdirs: $(SUBDIRS)

$(SUBDIRS) :
	make -C $@ $(MAKECMDGOALS)

################################################################
# Auto regenerate makefile / rerun configure                   #
################################################################

$(abs_srcdir)/configure: $(abs_srcdir)/configure.ac $(abs_srcdir)/prepare
	@echo Build files out of date. Rerunning prepare
	@( cd $(abs_srcdir); ./prepare )

$(builddir)/config.status: $(abs_srcdir)/configure
	@echo Build files out of date. Rerunning configure
	@$(builddir)/config.status --recheck

$(builddir)/Makefile: $(abs_srcdir)/Makefile.in $(builddir)/config.status
	@echo Build files out of date. Rerunning config.status
	@$(builddir)/config.status

define addmoddep =
$(builddir)/$(1)/module.mk: $(abs_srcdir)/$(1)/module.mk.in
	@$(builddir)/config.status
endef

$(foreach mod,$(MODULES),$(eval $(call addmoddep,$(mod))))

.PHONY: buildsys
buildsys: $(builddir)/Makefile $(patsubst %,$(builddir)/%/module.mk,$(MODULES)) \
		$(abs_srcdir)/configure

all:: buildsys

################################################################
# Makefile includes

# this is how we pull build information from all of the project
#    subdirectories, make sure to catch top level module.mk as well
include $(patsubst %, %/module.mk, $(MODULES)) module.mk

# Just like dir, but strip the slash off the end, to be pretty.
dirname = $(patsubst %/,%,$(dir $(1)))

# Generate the canonical in-tree location of a file, given a possible out
# of tree reference.
canonname = $(patsubst $(srcdir)/%,%,$(call dirname,$(1)))

canonfname = $(patsubst $(srcdir)/%,%,$(1))

# the "lastword" function is more concise, but not available on
# older versions of GNU Make
# bname = $(lastword $(subst /, ,$(1)))
bname = $(word $(words $(subst /, ,$(1))),$(subst /, ,$(1)))

canondirname = $(subst /,_,$(1))

################################################################
# Derived file lists

# NOTES: At this point, the subdirectory makefile includes have informed
#    us what the source files are.  Now we want to generate some
#    other lists (such as objects, executables, and dependency files)
#    by manipulating the lists of source files

# Grab any CFLAGS defined by the make stub for a particular file, and
# for the directory in which the source resides.
# Similar for ldflags.
modcflags = $(MODCFLAGS_$(call canonname,$(1))) \
            $(MODCFLAGS_$(patsubst $(srcdir)/%,%,$(1)))

MODCFLAGS_AER = $(call modcflags,$(1))
MODCFLAGS_AE = $(call modcflags,$(1))
MODCFLAGS_C = $(call modcflags,$(1))

modldflags = $(MODLDFLAGS_$(call canonname,$(1))) \
             $(MODLDFLAGS_$(patsubst $(srcdir)/%,%,$(1)))

MODLDFLAGS_AER = $(call modldflags,$(1))
MODLDFLAGS_AE = $(call modldflags,$(1))
MODLDFLAGS_C = $(call modldflags,$(1))

modlibs = $(MODLIBS_$(call canonname,$(1))) \
	  $(MODLIBS_$(patsubst $(srcdir)/%,%,$(1)))

MODLIBS_AER = $(call modlibs,$(1))
MODLIBS_AE = $(call modlibs,$(1))
MODLIBS_C = $(call modlibs,$(1))

modname = $(MODNAME_$(call canonname,$(1))) \
	  $(MODNAME_$(patsubst $(srcdir)/%,%,$(1)))

# use TCC variable so that we can keep CC as the system compiler
TCC = $(if $(MPICC),$(MPICC),$(CC))
CPPCC = $(CC)

modcc = $(if $(MODCC_$(1)),$(MODCC_$(1)),$(TCC))

MCC_AER = $(call modcc,$(1))
MCC_AE = $(call modcc,$(1))
MCC_C = $(call modcc,$(1))

# Get the parameters for a given test
testparams = $(TESTPARAMS_$(1))

# The object files for the triton library generated from .ae files
AELIBOBJS=$(patsubst %.ae,%.o,$(AELIBSRC))
aelibobjs: $(AELIBOBJS)

# The object files for the triton library generated from .c files
LIBOBJS=$(patsubst %.c,%.o,$(LIBSRC))
LIBDEPS=$(patsubst %.c,%.d,$(LIBSRC))

GENLIBOBJS=$(patsubst %.c,%.o,$(GENLIBSRC))
GENLIBDEPS=$(patsubst %.c,%.d,$(GENLIBSRC))
GENLIBFILES=$(GENLIBSRC) $(GENLIBHDR)

TESTOBJS=$(patsubst %.c,%.o,$(TESTSRC))
TESTDEPS=$(patsubst %.c,%.d,$(TESTSRC))

TEST=$(patsubst %.c,%,$(TESTSRC))

PROGRAMOBJS=$(patsubst %.c,%.o,$(PROGRAMSRC))
PROGRAM=$(patsubst %.c,%,$(PROGRAMSRC))

# The object files for binary tests generated from .ae files
AETESTOBJS=$(patsubst %.ae,%.o,$(AETESTSRC))

# The binary files from .ae test files
AETEST=$(patsubst %.ae,%,$(AETESTSRC))

AEPROGRAMOBJS=$(patsubst %.ae,%.o,$(AEPROGRAMSRC))
AEPROGRAM=$(patsubst %.ae,%,$(AEPROGRAMSRC))

# The C header files generated from .hae files
AESOP_TRHDR=$(patsubst %.hae,%.h,$(AESOP_HDR))
AESOP_TRHDR_DEPS=$(patsubst %.hae,%.h.d,$(AESOP_HDR))

# The object files for the triton test library generated from .ae files
AETESTLIBOBJS=$(patsubst %.ae,%.o,$(AETESTLIBSRC))

AEOBJS=$(AETESTLIBOBJS) $(AETESTOBJS) $(AELIBOBJS)
AEDEPS=$(patsubst %.o,%.ae.d,$(AEOBJS))

# The object files for the test library generated from .c files
TESTLIBOBJS=$(patsubst %.c,%.o,$(TESTLIBSRC))
TESTLIBDEPS=$(patsubst %.c,%.d,$(TESTLIBSRC))

HSBIN=$(patsubst %.lhs,%,$(HSBINSRC))
HSOBJ=$(patsubst %.lhs,%.o,$(filter %.lhs,$(HSSRC))) \
      $(patsubst %.hs,%.o,$(filter %.hs,$(HSSRC)))
HSINT=$(patsubst %.lhs,%.hi,$(filter %.lhs,$(HSSRC))) \
      $(patsubst %.hs,%.hi,$(filter %.hs,$(HSSRC)))

DEPENDS=$(TESTDEPS) $(GENLIBDEPS) $(LIBDEPS) $(AEDEPS) $(AESOP_TRHDR_DEPS) $(TESTLIBDEPS)

PROGRAMS = $(AEPROGRAM) $(PROGRAM)

TESTS = $(AETEST) $(TEST)

# TODO: Need a way to take mpiexec tests out of this
runTESTS = $(patsubst %,run%,$(TESTS))
runVALGRIND = $(patsubst %,valgrind%,$(TESTS))

# for now we just use static if we're not on a mac
ifneq (,$(USE_DYLIBS))
LIBRARIES=lib/libaesop.dylib
TEST_LIBRARIES=lib/libaesop-test.dylib
else
LIBRARIES=lib/libaesop.a
TEST_LIBRARIES=lib/libaesop-test.a
endif



DOCHTML=$(patsubst %.txt,%.html,$(ASCIIDOCSRC))
DOCPDF=$(patsubst %.txt,%.pdf,$(ASCIIDOCSRC))

CLEANDOC=
CLEANDOC+=$(patsubst %.txt,%.html,$(ASCIIDOCSRC))
CLEANDOC+=$(patsubst %.txt,%.pdf,$(ASCIIDOCSRC))
CLEANDOC+=$(patsubst %.txt,%.ditta_txt,$(ASCIIDOCSRC))

####################################################################
# Rules and dependencies

# Normal rules

$(TEST): %: %.o $(LIBRARIES) $(TEST_LIBRARIES)
	$(Q) "  LD		$@"
	$(E)$(call MCC_C,$*) \
		-o $@ $< $(LDFLAGS) \
		-L$(builddir)/lib -laesop-test -laesop $(call MODLIBS_C,$*) \
		$(LIBS)

$(PROGRAM): %: %.o $(LIBRARIES) $(TEST_LIBRARIES)
	$(Q) "  LD		$@"
	$(E)$(call MCC_C,$*) \
		-o $@ $< $(LDFLAGS) \
		-L$(builddir)/lib -laesop $(call MODLIBS_C,$*) \
		$(LIBS)

$(AETEST): %: %.o $(LIBRARIES) $(TEST_LIBRARIES)
	$(Q) "  LD (AETEST)	$@"
	$(E)$(call MCC_AE,$*) \
		-o $@ $< $(LDFLAGS)  \
		-L$(builddir)/lib -laesop-test -laesop \
		$(call MODLDFLAGS_AE,$*) $(call MODLIBS_AE,$*) \
		$(LIBS)

$(AEPROGRAM): %: %.o $(LIBRARIES)
	$(Q) "  LD		$@"
	$(E)$(call MCC_AE,$*) \
		-o $@ $< $(LDFLAGS) \
		-L$(builddir)/lib -laesop \
		$(call MODLDFLAGS_AE,$*) $(call MODLIBS_AE,$*) \
		$(LIBS)

$(GENLIBOBJS) $(LIBOBJS) $(TESTOBJS): %.o: %.c
	$(Q) "  CC		$@"
	$(E)$(call MCC_C,$*) -c -o $@ \
			$(LIBCFLAGS) $(CFLAGS) $(CWARNS) \
			$(call MODCFLAGS_C,$*) $<

# Auto-generated dependencies for .c files
$(LIBDEPS) $(GENLIBDEPS) $(TESTDEPS) $(TESTLIBDEPS): %.d: %.c
	$(Q) "  DEP           $@"
	$(E)CC=$(call MCC_C,$*) $(srcdir)/maint/depend.sh $(call dirname,$*) $(LIBCFLAGS) $(CFLAGS) $(call MODCFLAGS_C,$*) $< > $@

$(TESTLIBOBJS): %.o: %.c

	$(Q) "  CC		$@"
	$(E)$(call MCC_C,$*) -c -o $@ \
		$(LIBCFLAGS) $(CFLAGS) $(CWARNS) \
		$(call MODCFLAGS_C,$*) $<

lib/libaesop.a: $(AELIBOBJS) $(LIBOBJS) $(GENLIBOBJS)
	$(Q) "  RANLIB  	$@"
	$(E)$(INSTALL) -d lib
	$(E)ar rcs $@ $(AELIBOBJS) $(LIBOBJS) $(GENLIBOBJS)

# shared objects

lib/libaesop.so: $(AELIBOBJS) $(LIBOBJS) $(GENLIBOBJS)
	$(Q) "  LDSO  	        $@"
	$(E)$(INSTALL) -d lib
	$(E)$(LDSHARED) -Wl,-soname,libaesop.so -o $@ $(AELIBOBJS) $(LIBOBJS) $(GENLIBOBJS)

lib/libaesop.dylib: $(AELIBOBJS) $(LIBOBJS)
	$(Q) " DYLIB		$@"
	$(E)$(INSTALL) -d lib
	$(E)$(TCC) -o lib/libaesop.dylib -dynamiclib -current_version 0.0.1 -install_name lib/libaesop.0.0.1.dylib \
		$(AELIBOBJS) $(LIBOBJS) $(DEPLIBS)


# --- aesop-test ----

lib/libaesop-test.a: $(AETESTLIBOBJS) $(TESTLIBOBJS) $(REMOTE_TESTLIB_OBJS)
	$(Q) "  RANLIB          $@"
	$(E)$(INSTALL) -d lib
	$(E)ar rcs $@ $(AETESTLIBOBJS) $(TESTLIBOBJS) $(REMOTE_TESTLIB_OBJS)

lib/libaesop-test.so: $(AETESTLIBOBJS) $(TESTLIBOBJS)
	$(Q) "  LDSO            $@"
	$(E)$(INSTALL) -d lib
	$(E)$(LDSHARED) -Wl,-soname,libaesop-test.so -o $@ $(AETESTLIBOBJS) $(TESTLIBOBJS)

lib/libaesop-test.dylib: $(AETESTLIBOBJS) $(TESTLIBOBJS)
	$(Q) " DYLIB            $@"
	$(E)$(INSTALL) -d lib
	$(E)$(TCC) -o lib/libtriton-test.dylib -dynamiclib -current_version 0.0.1 \
	   		-install_name lib/libaesop-test.0.0.1.dylib \
                $(AETESTLIBOBJS) $(TESTLIBOBJS) $(DEPLIBS) -L$(builddir)/lib \
		-laesop



# AE rule compiles *.ae files to object files
#
$(AEOBJS): %.o: $(HSBIN) %.ae
	$(Q) "  AECC		$*.ae"
	$(E)$(builddir)/bin/aecc -o $(builddir)/$*.o $(srcdir)/$*.ae \
                -c $(call MCC_AE,$*) $(VA) $(DA) $(AEPRETTY) \
                -- $(LIBCFLAGS) $(CFLAGS) $(CWARNS) $(call MODCFLAGS_AE,$*)

# Auto-generated dependencies for .ae files
$(AEDEPS): %.ae.d: %.ae
	$(Q) "  DEP           $@"
	$(E)CC=$(call MCC_C,$*) $(srcdir)/maint/depend-ae.sh $(call dirname,$*) $(srcdir) $(LIBCFLAGS) $(CFLAGS) $(call MODCFLAGS_C,$*) $< > $@

# Generate header files (%.h) from AE header files
# NOTE: this is used by resource .c files that need to include the .h
# version of the .hae file that defines the resource interface
$(AESOP_TRHDR): %.h: %.hae $(HSBIN)

	$(Q) "  AECC		$*.hae"
	$(E)$(builddir)/bin/aecc -o $(builddir)/$*.h $(srcdir)/$*.hae \
                -j -c $(call MCC_AE,$*) $(VA) $(DA) $(AEPRETTY) \
                -- $(LIBCFLAGS) $(CFLAGS) $(CWARNS) $(call MODCFLAGS_AE,$*)

$(AESOP_TRHDR_DEPS): %.h.d: %.hae
	$(Q) "  DEP           $@"
	$(E)CC=$(call MCC_C,$*) $(srcdir)/maint/depend-hae.sh $(call dirname,$*) $(srcdir) $(LIBCFLAGS) $(CFLAGS) $(call MODCFLAGS_C,$*) $< > $@

# TODO: we need a better solution here.  The problem is that the
# auto-dependencies often include generated headers.  If we make the .d
# files themselves depend on those same files, then we have to generate all
# headers to produce dependency files before doing anything else.  This
# takes a long time.  For now I'm adding this brute force rule to regen all
# dependency information if any non-generated headers change.  Rebuilding
# all dependency files is faster than compiling one superfluous .aer file.
DEP_PREREQS :=
DEP_PREREQS += $(shell find $(srcdir) -name "*.haer")
DEP_PREREQS += $(shell find $(srcdir) -name "*.hae")
DEP_PREREQS += $(shell find $(srcdir) -name "*.h")
%.d: $(DEP_PREREQS)

# Compile parsers from haskell source using GHC

$(HSBIN): %: $(srcdir)/%.lhs $(HSSRC)
	$(Q) "  GHC		$@"
	$(E)$(GHC) -O2 -odir $(call canonname,$<) \
		   -hidir $(call canonname,$<) \
		   -o $@ \
		   -main-is $(call modname,$<) \
		-i$(call dir,$<) --make $< >/dev/null

# User targets

all::  $(PROGRAMS) $(LIBRARIES)

$(runTESTS): run%: %
	@if test -n "$(call testparams,$<)"; then \
		for p in $(call testparams,$<); do \
			echo -n "Running $< $$p..."; \
			./$< $$p > /dev/null; \
			echo "done."; \
		done \
	else \
		echo -n "Running $<..."; \
		./$< > /dev/null; \
		echo "done."; \
	fi

check: $(runTESTS) test_results

.PHONY: tests
tests: test

.PHONY: test
test: $(TESTS)

test_results: $(TEST_RESULTS)

$(runVALGRIND): valgrind%: %
	@if test -n "$(call testparams,$<)"; then \
		for p in $(call testparams,$<); do \
			echo -n "Running valgrind $< $$p..."; \
			valgrind --error-exitcode=1 ./$< $$p > /dev/null 2>./.vout; \
			grep "All heap blocks were freed" ./.vout >/dev/null 2>&1; \
			if test $$? != 0; then \
				echo "\nErrors found in $<. Rerun valgrind ./$<"; \
				exit 1; \
			fi; \
			echo "done."; \
		done; \
	else \
		echo -n "Running valgrind $<..."; \
		valgrind --error-exitcode=1 ./$< > /dev/null 2>./.vout; \
		grep "All heap blocks were freed" ./.vout >/dev/null 2>&1; \
		if test $$? != 0; then \
			echo "\nErrors found in $<.  Rerun valgrind ./$<"; \
			exit 1; \
		fi; \
		echo "done."; \
	fi

runvalgrind: $(runVALGRIND)

%.result: % %.sh
	$(Q) "  SH		$@"
	$(E) SRCDIR=$(srcdir) $(srcdir)/$(patsubst %,%.sh,$<) > \
		$*.tmp 2>&1
	$(E) mv $*.tmp $@
	$(E) echo -n "    		$@ : " && cat $@

# other intermediates may exist from aecc and aercc
INTERM_AESRC=$(patsubst %.o,%.ae.i.s,$(AEOBJS))
INTERM_AEINC=$(patsubst %.o,%.ae.i,$(AEOBJS))
INTERM_HAEINC=$(patsubst %.h,%.hae.i,$(AESOP_TRHDR))

INTERM=$(INTERM_AESRC) \
       $(INTERM_AEINC) \
       $(INTERM_HAEINC)

clean:: docclean
	$(Q) "  CLEAN"
	$(E)rm -f $(AEOBJS) $(LIBOBJS) $(GENLIBOBJS) $(AETEST) $(AEPROGRAM) $(TEST) $(PROGRAM) \
	        $(AESOP_TRHDR) $(TESTLIBOBJS) \
	        $(LIBRARIES) $(TEST_LIBRARIES) $(DEPENDS) $(TEST_RESULTS) $(TEST_OUT) \
                $(INTERM)

parserclean::
	$(Q) "  PARSER CLEAN"
	$(E)rm -f $(HSBIN) $(HSOBJ) $(HSINT)


.PHONY: docclean
docclean:
	$(Q) "  DOCCLEAN"
	$(E) rm -f $(CLEANDOC)

# this is where we include all of our automatic dependencies.
# NOTE: we wrap this in ifneq's in order to prevent the dependencies
# from being generated for special targets that don't require them
ifeq (,$(filter clean parserclean nodep,$(MAKECMDGOALS)))
-include $(DEPENDS)
endif
# add this as a make goal to disable rebuilding deps
.PHONY: nodep
.nodep:; @:

# rule for generating cscope information
cscope:
	find @SRC_ABSOLUTE_TOP@ -regex ".*\.\(c\|h\|ae\|hae\|aer\|haer\)" -o -iname "*.sm" \
                > $(srcdir)/cscope.files
	( cd @SRC_ABSOLUTE_TOP@; cscope -be -i @SRC_ABSOLUTE_TOP@/cscope.files )

tags::
	find @SRC_ABSOLUTE_TOP@ -regex ".*\.\(c\|h\|ae\|hae\|aer\|haer\)" | ctags -L- --excmd=pattern -B --extra=+f --langmap=c:+.ae.aer.hae.haer -I pwait,pbranch -f @SRC_ABSOLUTE_TOP@/tags

etags:
#	Note: this only reads src and prunes the test directories
	cd @SRC_ABSOLUTE_TOP@ ; find src \
	-name test -prune -o -name tests -prune -o \
	-regex ".*\.\(c\|h\|ae\|hae\|aer\|haer\)" -print \
	| xargs etags

#%.txt: %.doc
#	$(srcdir)/maint/handle-ditaa.py -j $(srcdir)/maint/ditaa/ditaa.jar -d $(dir $@) $< > $@
#
%.html: %.ditta_txt
	$(ASCIIDOC) -a data-uri -a icons -a toc -a max-width=55em $<

%.pdf: %.ditta_txt $(builddir)/doc/fig
	$(A2X) -L -v -v -a buildpath=$(abs_srcdir)/doc --dblatex-opts "-P latex.output.revhistory=0" -a data-uri -a icons -a toc -a max-width=55em $<

$(builddir)/doc/fig: $(abs_srcdir)/doc/fig
	ln -s $< $@

.INTERMEDIATE: %.ditta_txt
%.ditta_txt: %.txt
	$(srcdir)/maint/handle-ditaa.py -j $(srcdir)/maint/ditaa/ditaa.jar -d $(dir $@) $< > $@


.PHONY: docs doc docshtml dochtml
docs: $(DOCPDF)
doc: $(DOCPDF)
docshtml: $(DOCHTML)
dochtml: $(DOCHTML)

install:: all
	install -d $(bindir)
	install -d $(libdir)
	install -d $(includedir)
	install -m 755 bin/aecc $(bindir)
	install -m 755 bin/aecc-utils $(bindir)
	install -m 644 lib/libaesop.* $(libdir)
	install -m 644 $(srcdir)/src/c-utils/triton-list.h $(includedir)
	install -m 644 $(srcdir)/ae-types.h $(includedir)
	install -m 644 $(srcdir)/ae-ctl.h $(includedir)
	install -m 644 $(srcdir)/ae-log.h $(includedir)
	install -m 644 $(srcdir)/aesop.h $(includedir)
	install -m 644 $(srcdir)/ae-error.h $(includedir)
	install -m 644 $(srcdir)/ae-blocking-parser.h $(includedir)
	install -m 644 $(srcdir)/resource.h $(includedir)
	install -m 644 $(srcdir)/hints.h $(includedir)
	install -m 644 $(srcdir)/opcache.h $(includedir)
	install -m 644 $(srcdir)/ae-init.h $(includedir)
	install -m 644 $(srcdir)/src/c-utils/triton-thread.h $(includedir)
	install -m 644 $(srcdir)/src/c-utils/triton-base.h $(includedir)
	install -m 644 $(srcdir)/ae-debug.h $(includedir)
	install -m 644 $(srcdir)/op.h $(includedir)
