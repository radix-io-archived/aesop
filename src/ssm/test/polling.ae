/*
 * (C) 2009 The University of Chicago
 *
 * See COPYRIGHT in top-level directory.
 */

#include <aesop/aesop.h>
#include <aesop/aessm.hae>

#define DATAVAL 0xffbaffabffbaffab

/*
 * Put
 */
__blocking int test_put(void)
{
    aessm_t ssm1;
    ssm_me_id me1;
    ssm_iovec_t iovec1;
    uint64_t    data1 = 0;
    ssm_evt_t   evt1;
    int rc1;

    aessm_t ssm2;
    ssm_me_id me2;
    ssm_iovec_t iovec2;
    uint64_t    data2 = DATAVAL;
    ssm_evt_t   evt2;
    int rc2;

    // publish buffer 
    rc1 = aessm_initialize(&ssm1, AESSM_MODE_POLL);
    assert(rc1 == AE_SUCCESS);

    iovec1.data = &data1;
    iovec1.len  = sizeof(data1);
    iovec1.next = NULL;

    rc1 = aessm_link (&ssm1,
                      0,
                      0x1234,
                      0, 
                      &iovec1,
                      SSM_ME_POS_HEAD,
                      SSM_ME_NONE, 
                      1,
                      &me1);
    assert(rc1 == AE_SUCCESS);

    pwait
    {
        // wait for put
        pbranch
        {
            memset(&evt1, 0, sizeof(evt1));

            rc1 = aessm_wait (me1, &evt1);
            assert(rc1 == AE_SUCCESS);
            assert(evt1.result == SSM_RESULT_SUCCESS);
            assert(data1 == DATAVAL);

            memset(&evt1, 0, sizeof(evt1));

            rc1 = aessm_unlink (me1, &evt1);
            assert(rc1 == AE_SUCCESS);
            assert(evt1.result == SSM_RESULT_SUCCESS);

            rc1 = aessm_finalize(&ssm1);
            assert(rc1 == AE_SUCCESS);
        }

        // post put to remote
        pbranch
        {
            memset(&evt2, 0, sizeof(evt2));

            iovec2.data = &data2;
            iovec2.len  = sizeof(data2);
            iovec2.next = NULL;

            rc2 = aessm_initialize(&ssm2, AESSM_MODE_POLL);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_link (&ssm2,
                              SSM_ME_SEND_ONLY,
                              0x1234,
                              0, 
                              &iovec2,
                              SSM_ME_POS_HEAD,
                              SSM_ME_NONE, 
                              0,
                              &me2);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_put(me2, ssm1.laddr_id, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);
            assert(data2 == DATAVAL);

            memset(&evt2, 0, sizeof(evt2));

            rc2 = aessm_unlink(me2, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);

            rc2 = aessm_finalize(&ssm2);
            assert(rc2 == AE_SUCCESS);
        }
    }

    printf("PUT SUCCESS\n");
    return 0;

}

/*
 * Get
 */
__blocking int test_get (void)
{
    aessm_t     ssm1;
    ssm_me_id   me1;
    ssm_iovec_t iovec1;
    uint64_t    data1 = DATAVAL;
    ssm_evt_t   evt1;
    int         rc1;

    aessm_t     ssm2;
    ssm_me_id   me2;
    ssm_iovec_t iovec2;
    uint64_t    data2 = 0;
    ssm_evt_t   evt2;
    int         rc2;


    // publish buffer to get from

    rc1 = aessm_initialize(&ssm1, AESSM_MODE_POLL);
    assert(rc1 == AE_SUCCESS);

    iovec1.data = &data1;
    iovec1.len  = sizeof(data1);
    iovec1.next = NULL;

    rc1 = aessm_link (&ssm1,
                      0,
                      0x1234,
                      0, 
                      &iovec1,
                      SSM_ME_POS_HEAD,
                      SSM_ME_NONE, 
                      1,
                      &me1);
    assert(rc1 == AE_SUCCESS);

    pwait
    {
        // wait for get
        pbranch
        {
            memset(&evt1, 0, sizeof(evt1));

            rc1 = aessm_wait (me1, &evt1);
            assert(rc1 == AE_SUCCESS);
            assert(evt1.result == SSM_RESULT_SUCCESS);
            assert(data1 == DATAVAL);

            memset(&evt1, 0, sizeof(evt1));

            rc1 = aessm_unlink (me1, &evt1);
            assert(rc1 == AE_SUCCESS);
            assert(evt1.result == SSM_RESULT_SUCCESS);

            rc1 = aessm_finalize(&ssm1);
            assert(rc1 == AE_SUCCESS);
        }

        // get from remote
        pbranch
        {
            memset(&evt2, 0, sizeof(evt2));

            iovec2.data = &data2;
            iovec2.len  = sizeof(data2);
            iovec2.next = NULL;

            rc2 = aessm_initialize(&ssm2, AESSM_MODE_POLL);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_link (&ssm2,
                              //SSM_ME_SEND_ONLY, // this should work?
                              0,
                              0x1234,
                              0, 
                              &iovec2,
                              SSM_ME_POS_HEAD,
                              SSM_ME_NONE, 
                              0,
                              &me2);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_get(me2, ssm1.laddr_id, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);
            assert(data2 == DATAVAL);

            memset(&evt2, 0, sizeof(evt2));

            rc2 = aessm_unlink(me2, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);

            rc2 = aessm_finalize(&ssm2);
            assert(rc2 == AE_SUCCESS);
        }
    }

    printf("GET SUCCESS\n");
    return 0;
}

/*
 * Msg
 */
__blocking int test_msg (void)
{
    aessm_t     ssm1;
    ssm_me_id   me1;
    ssm_evt_t   evt1;
    int         rc1;

    aessm_t     ssm2;
    ssm_me_id   me2;
    ssm_evt_t   evt2;
    int         rc2;

    // publish match for msg

    rc1 = aessm_initialize(&ssm1, AESSM_MODE_POLL);
    assert(rc1 == AE_SUCCESS);

    rc1 = aessm_link (&ssm1,
                      0,
                      0x1234,
                      0, 
                      NULL,
                      SSM_ME_POS_HEAD,
                      SSM_ME_NONE, 
                      1,
                      &me1);
    assert(rc1 == AE_SUCCESS);

    pwait
    {
        // wait for match
        pbranch
        {
            memset(&evt1, 0, sizeof(evt1));

            rc1 = aessm_wait (me1, &evt1);
            assert(rc1 == AE_SUCCESS);
            assert(evt1.result == SSM_RESULT_SUCCESS);
            assert(evt1.info_a == DATAVAL);
            assert(evt1.info_b == ~DATAVAL);

            memset(&evt1, 0, sizeof(evt1));

            rc1 = aessm_unlink (me1, &evt1);
            assert(rc1 == AE_SUCCESS);
            assert(evt1.result == SSM_RESULT_SUCCESS);

            rc1 = aessm_finalize(&ssm1);
            assert(rc1 == AE_SUCCESS);
        }

        // post msg to remote
        pbranch
        {
            uint64_t    dataA = DATAVAL;
            uint64_t    dataB = ~DATAVAL;

            memset(&evt2, 0, sizeof(evt2));

            rc2 = aessm_initialize(&ssm2, AESSM_MODE_POLL);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_link (&ssm2,
                              SSM_ME_SEND_ONLY,
                              0x1234,
                              0,
                              NULL, 
                              SSM_ME_POS_HEAD,
                              SSM_ME_NONE, 
                              0,
                              &me2);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_msg(me2, ssm1.laddr_id, dataA, dataB, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);
            assert(dataA == DATAVAL);
            assert(dataB == ~DATAVAL);

            memset(&evt2, 0, sizeof(evt2));

            rc2 = aessm_unlink(me2, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);

            rc2 = aessm_finalize(&ssm2);
            assert(rc2 == AE_SUCCESS);
        }
    }

    printf("MSG SUCCESS\n");
    return 0;
}

/*
 * Ping
 */
__blocking int test_ping (void)
{
    aessm_t   ssm1;
    int       rc1;

    aessm_t   ssm2;
    ssm_me_id me2;
    ssm_evt_t evt2;
    int       rc2;

    // initialize for ping

    rc1 = aessm_initialize(&ssm1, AESSM_MODE_POLL);
    assert(rc1 == AE_SUCCESS);

    pwait
    {
        // wait for ping
        pbranch
        {
            aesop_timer(1000);

            rc1 = aessm_finalize(&ssm1);
            assert(rc1 == AE_SUCCESS);
        }

        // post ping to remote
        pbranch
        {
            memset(&evt2, 0, sizeof(evt2));

            rc2 = aessm_initialize(&ssm2, AESSM_MODE_POLL);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_link (&ssm2,
                              //SSM_ME_SEND_ONLY,
                              0,
                              0,
                              0,
                              NULL, 
                              SSM_ME_POS_HEAD,
                              SSM_ME_NONE, 
                              0,
                              &me2);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_ping(me2, ssm1.laddr_id, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);

            memset(&evt2, 0, sizeof(evt2));

            rc2 = aessm_unlink(me2, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);

            rc2 = aessm_finalize(&ssm2);
            assert(rc2 == AE_SUCCESS);
        }
    }

    printf("PING SUCCESS\n");
    return 0;
}


/*
 * This test demonstrates a put into a remote buffer.
 */
__blocking int test_main (int argc, char **argv)
{
    test_put();
    test_get();
    test_msg();
    test_ping();

    return 0;
}

aesop_main_set(test_main);

/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
