#include "aesop.h"
#include "aesop-support.hae"
#include "src/ssm/aessm.hae"

#define DATAVAL 0xffbaffabffbaffab

/*
 * This test demonstrates a get from a remote buffer.
 */
static __blocking int test_main (int argc, char **argv)
{
    aessm_t     ssm1;
    ssm_me_id   me1;
    ssm_iovec_t iovec1;
    uint64_t    data1 = DATAVAL;
    ssm_evt_t   evt1;
    int         rc1;

    aessm_t     ssm2;
    ssm_me_id   me2;
    ssm_iovec_t iovec2;
    uint64_t    data2 = 0;
    ssm_evt_t   evt2;
    int         rc2;


    // publish buffer to get from

    rc1 = aessm_initialize(&ssm1);
    assert(rc1 == AE_SUCCESS);

    iovec1.data = &data1;
    iovec1.len  = sizeof(data1);
    iovec1.next = NULL;

    rc1 = aessm_link (ssm1.ssm,
                      0,
                      0x1234,
                      0, 
                      &iovec1,
                      SSM_ME_POS_HEAD,
                      SSM_ME_NONE, 
                      1,
                      &me1);
    assert(rc1 == AE_SUCCESS);

    pwait
    {
        // wait for get
        pbranch
        {
            memset(&evt1, 0, sizeof(evt1));

            rc1 = aessm_wait (me1, &evt1);
            assert(rc1 == AE_SUCCESS);
            assert(evt1.result == SSM_RESULT_SUCCESS);
            assert(data1 == DATAVAL);

            memset(&evt1, 0, sizeof(evt1));

            rc1 = aessm_unlink (me1, &evt1);
            assert(rc1 == AE_SUCCESS);
            assert(evt1.result == SSM_RESULT_SUCCESS);

            rc1 = aessm_finalize(&ssm1);
            assert(rc1 == AE_SUCCESS);
        }

        // get from remote
        pbranch
        {
            memset(&evt2, 0, sizeof(evt2));

            iovec2.data = &data2;
            iovec2.len  = sizeof(data2);
            iovec2.next = NULL;

            rc2 = aessm_initialize(&ssm2);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_link (ssm2.ssm,
                              //SSM_ME_SEND_ONLY, // this should work?
                              0,
                              0x1234,
                              0, 
                              &iovec2,
                              SSM_ME_POS_HEAD,
                              SSM_ME_NONE, 
                              0,
                              &me2);
            assert(rc2 == AE_SUCCESS);

            rc2 = aessm_get(me2, ssm1.laddr_id, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);
            assert(data2 == DATAVAL);

            memset(&evt2, 0, sizeof(evt2));

            rc2 = aessm_unlink(me2, &evt2);
            assert(rc2 == AE_SUCCESS);
            assert(evt2.result == SSM_RESULT_SUCCESS);

            rc2 = aessm_finalize(&ssm2);
            assert(rc2 == AE_SUCCESS);
        }
    }

    printf("SUCCESS\n");
    return 0;
}

aesop_main_set(test_main);

/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
