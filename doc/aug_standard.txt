
[[ref-library]]
The Aesop Standard Library
==========================

Aesop System Interfaces and Tools
----------------------------------


Configuration Interface
~~~~~~~~~~~~~~~~~~~~~~~

Aesop provides a unified interface to advertise and set configuration
parameters across all registered resources.  This section describes both
the Aesop user interface to this functionality as well as the Aesop library
author's interface to this functionality.

Querying and setting configuration parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following function can be used to set arbitrary configuration
parameters:

----
int aesop_set_config(const char* key, const char* value);
----

The `key` argument is the name of the configuration parameter to be set,
while the `value` argument is the new value for that configuration
parameter.  All values must be provided as strings.  The function returns 0
on success, `AE_ERR_NOT_FOUND` if the key is not known to Aesop, or
`AE_ERR_INVAL` if the key is valid but the value is not. 

There is currently no corresponding function to query a configuration
parameter or list available keys (as of February 2012), although this will be 
added in future versions of Aesop.

Registering new configuration parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When a resource is registered with the Triton library using the
`ae_resource_register()` function, the resource author has the option of
specifying configuration parameters for that resource using the
`config_array` field of the required `ae_resource` struct.  The 
`config_array` field is a `NULL` terminated array of structs of type `struct
ae_resource_config`, which is defined as follows:

----
struct ae_resource_config
{
    const char* name;
    const char* default_value;
    const char* description;
    int (*updater)(const char* key, const char* value);
};
----

The `name` field is the name of the configuration parameter (which
corresponds to the `key` argument of the `aesop_set_config()` function).
The `default_value` field specifies the starting value of the configuration
parameter.  The `description` is a free form text field, though standard
practice is to limit this to a single line of text describing the
configuration parameter.  The `updater` field is a pointer to a function
that will be invoked when the configuration parameter is updated.  The
resource must provide this function and handle configuration updates in a
manner appropriate for the resource.  For example, this function may
perform an `sscanf()` to read an integer value, and then check its values
against the legal ranges for the parameter before accepting it.  The
resource should return 0 on success or `AE_ERR_INVALID` if the configuration
value is not valid.

The `config_array` field can be set to `NULL` at resource registration time
if the resource does not support any configuration parameters.

As of February 2012 this functionality is only avaialable to resources, but
in future work we will extend this concept to allow arbitrary Aesop
components to register configuration parameters in a similar manner.

Debugging
~~~~~~~~~~

// TODO: talk about problem using gdb



The code injected by the aesop translator supports writing tracing
information to `stderr`.

The following components can be traced:

[horizontal]
*blocking*:: Outputs when a blocking call is initiated and finished.

*cancel*:: Outputs information regarding cancellation of blocking calls.

*pbranch*:: Tracks the creation and completion of pbranches.

The following call can be used to enable or disable tracing for a component.

----
int aesop_set_debugging (const char * what, int value);
----

The `what` argument can be either one of the following strings:

* `"ae_blocking"`
* `"ae_pbranch"`
* `"ae_cancel"`

The `value` parameter can be set to `1` or `0`, in order to respectively
enable or disable tracing.


Standard Aesop modules
-----------------------

The following modules are bundled with the aesop distribution.

[[ref-timer]]
Timer
~~~~~~

Header: `triton.timer.hae`


----
int aesop_timer_init(void);
void aesop_timer_finalize(void);
-----

Before using any other timer function, the application is responsible for
calling `aesop_timer_init`. It is safe to call init more than once, as long
as one call to `aesop_timer_finalize` is made for every call to
`aesop_timer_init`.


-----
__blocking int aesop_timer(int millisecs);
----

The `aesop_timer` function will sleep for the given number of milliseconds.
The functions returns 0 on success, `-ECANCELED` if canceled before the sleep
time is over.

Socket
~~~~~~

Header: `aesocket.hae`

-----
int aesocket_init (void);
int aesocket_finalize (void);
----

Module initialization functions.


----
__blocking int aesocket_accept(
    int sockfd,
    struct sockaddr *addr,
    socklen_t * addrlen,
    int *newfd,
    int * err);
----

The aesop version of the accept system call.
Unlike the system call, the descriptor for the new connection is returned in
`*newfd`, while an error, if any, is returned in `*err`.
The function returns `AE_SUCCESS` when a new connection is accepted,
`AE_ERR_CANCELED` if the call was canceled and `AE_ERR_OTHER` if a system call
error occurred (returned in `*err`) occurred.



-----
__blocking int aesocket_read(
    int fd,
    void *buf,
    size_t count,
    int *ret,
    int * err);
----
Read `count` bytes from the given socket. This call will not return
until an error occurred or at `count` bytes were read from the socket.
The function returns `AE_SUCCESS` if the requested number of bytes was read,
`AE_ERR_CANCELED` if the call was canceled and `AE_ERR_OTHER` if another error
occured, in which case `*err` is set to the POSIX error code. The number of
bytes read into `buf` is returned in `*ret`.



----
__blocking int aesocket_write(
    int fd,
    const void *buf,
    size_t count,
    int *ret,
    int * err);
----
As `aesocket_read`, but writes data to the socket instead.

----
__blocking int aesocket_ready (int fd, int flags, int * err);
----

The `aesocket_ready` call waits until the passed in descriptor is ready to
perform the action specified in `flags`.
`Flags` can be a combination of `AESOCKET_READ` or `AESOCKET_WRITE`.
The function returns `AE_ERR_CANCELED` when canceled, `AE_ERR_OTHER` when an
error was returned by the underlying system call, and `AE_SUCCESS` otherwise.
In case of `AE_ERR_OTHER`, the error code is stored in `*err`.

This function is used internally to implement the `aesocket_read`,
`aesocket_write` and `aesocket_accept` functions.




File
~~~~

Header: `aefile.hae`

----
int aefile_init(void);
void aefile_finalize(void);
----
As with the other code modules, the init function needs to be called before
calling any of the functions below. 



----
__blocking ssize_t aefile_pwrite(int fd, const void *buf, size_t count, off_t offset);
__blocking ssize_t aefile_pread(int fd, void *buf, size_t count, off_t offset);
__blocking int aefile_fsync(int fd);
__blocking int aefile_fdatasync(int fd);
__blocking int aefile_ftruncate(int fd, off_t length);
__blocking int aefile_unlink(const char *pathname);
----
These are aesop versions of the regular `pwrite`, `pread`, `fsync`,
`fdatasync`, `ftruncate` and `unlink` functions.

[NOTE]
====
These functions are currently implemented using a thread which calls the
regular POSIX I/O function. These functions cannot be cancelled once the
operation started.
====


ResourceBuilder
~~~~~~~~~~~~~~~

Header: `resourcebuilder.hae`

----
void rb_slot_initialize (rb_slot_t * slot);
----

`rb_slot_t` is an opaque datatype.
Prepare a slot for using with the `rb_slot_capture` function.


----
__blocking int rb_slot_capture (rb_slot_t * slot);
----

This call will suspend execution until the call is cancelled or until
`rb_slot_complete` is called on the slot. A slot only supports a single
capture call (i.e. it is illegal to call capture on a slot that is already
captured). When the call is completed by a call to `rb_slot_complete`, this
function returns `AE_SUCCESS`, and `AE_ERR_CANCELED` when the call returns due
to a cancellation request.

After a call to this function, the slot needs to be destroyed (using
`rb_slot_destroy` and reinitialized before it can be used again.

----
int rb_slot_complete (rb_slot_t * slot);
----

Release a captured slot. This call returns `AE_SUCCESS` if it successfully
released a `rb_slot_capture` call on the slot. If the slot was not active (for
example because it was already cancelled), an unspecified aesop error code is
returned.

----
void rb_slot_destroy (rb_slot_t * slot);
----

Free resources associated with the slot. The slot must be inactive. It is
illegal to call this function on a slot that is currently captured.


[TIP]
====
The ResourceBuilder functions provide a low level toolkit used to build higher
level code. For example, the ResourceBuilder is used to implement the aesop
socket functions. ResourceBuilder is also a good basis for building
synchronization primitives, such as mutexes and semaphores.
====


thread
~~~~~~

WARNING: The thread module relies on internal details of the current aesop
implementation. Its use and interface might change in future versions.


The following functions are used to intialize and shut down the thread module.

----
int aethread_init(void);
void aethread_finalize(void);
----

The thread module provides the concept of a thread group. Groups are created
with a certain size, and cannot grow beyond this size.

----
struct aethread_group * aethread_create_group_pool(int size);
void aethread_destroy_group(struct aethread_group * group);
----


----
__blocking int aethread_hint(struct aethread_group * group);
----

The `aethread_hint` function is a blocking function which will complete when a
free thread can be found in the specified group. If all threads in the group
are in use, this function will wait until one becomes available.  When
returning from this call, *one of the threads of the specified group will be
used to continue execution*. With the current aesop translator, this means
that the code following the `aethread_hint` call will execute using one of the
threads of the group, until the thread becomes idle. 

[NOTE]
.Implementation Detail
====
In the current aesop implementation, a thread becomes idle when one of the
following happens:

* Entering a blocking call which cannot complete immediately.
* Finishing execution of a lonely pbranch.
* Waiting for other pbranches to complete in a `pwait`. The last thread to
  arrive at a `pwait` does _not_ become idle but will continue execution with
  the first statement following the `pwait` construct.
====

The `aethread_hint` function supports cancellation while waiting for a group
thread to become available. The function returns `AE_ERR_CANCELLED` when the
search was cancelled, or `AE_SUCCESS` in when execution successfully switched
to one of the group threads.

The thread module is mainly used to provide a blocking version of a regular C
function. See <<ref-thread>> for more details and an example.



